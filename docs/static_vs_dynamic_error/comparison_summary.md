Great. I will collect and compare all known techniques in C to determine a function’s address from within itself, focusing on debug builds, with support for x86 and ARM (both 32- and 64-bit), without external dependencies, and with support for inline assembly and dynamic linking.

I’ll outline methods like `__builtin_return_address`, inline assembly (e.g., accessing the link register or return address), label tricks, and their constraints across platforms.

I’ll let you know when it’s ready.

# Techniques for Determining a Function’s Own Address in C

Several methods can be used for a C function to obtain its own address at runtime. Below we list the major techniques (assuming **no compiler optimizations** for simplicity) and compare their behavior on x86 (32-bit & 64-bit) and ARM (32-bit & 64-bit). All methods avoid external libraries (no glibc, no libunwind) and work in both static and dynamically-linked binaries. For each technique, we note what address it yields (function entry, caller’s call-site, etc.), along with pros, cons, portability, and any compiler constraints.

## 1. Using the Function’s Name (Function Pointer to Itself)

In C, a function can directly take its own address by using its name as a function pointer. For example:

```c
void myfunc(void) {
    void (*fp)(void) = myfunc;  // pointer to myfunc (type matches)
    printf("Address of myfunc: %p\n", (void*)fp);
    // ...or return fp from the function
}
``` 

This yields the **entry point address** of `myfunc` (the start of the function’s code in memory). The function name in an expression decays to a function pointer value ([pointers - Get address of a function inside of the function in C/C++? - Stack Overflow](https://stackoverflow.com/questions/63395637/get-address-of-a-function-inside-of-the-function-in-c-c#:~:text=In%20C%20you%20can%20use,has%20the%20wrong%20return%20type)). You should use the correct function pointer type (e.g. the same signature as the function) rather than casting to `void*` directly to keep C type safety.

- **Pros:** Very simple and portable in standard C. Works on any architecture (x86, ARM, etc.) without needing assembly. No special compiler extensions required. The address obtained is the actual function’s start address (entry point).
- **Cons:** In strict ISO C, converting a function pointer to an object pointer (like `void*`) is technically undefined behavior. However, on common platforms (Unix/Linux, Windows on x86/ARM) function pointers are compatible with data pointers of the same size, so printing or storing as `void*` works in practice. Another consideration is that if the function is eligible for inlining or removal by the compiler in an optimized build, taking its address may prevent inlining but if the function **only** ever gets inlined, there may be no distinct address. (In debug builds, inlining is usually off, so not a problem.)
- **Portability:** Supported by all C/C++ compilers. No platform constraints aside from the pointer conversion note. This works in both statically-linked and dynamically-linked scenarios, but with dynamic linking one must note that if the function is not `static` or hidden, the address might refer to a procedure linkage table entry (PLT) rather than the raw function code. In practice, taking the address of a function defined in the same module will typically give the actual function address; however, on ELF binaries a non-static function’s address might resolve through a PLT stub if the function is interposable in another module. Marking the function as static or hidden ensures the pointer refers directly to the function code.
- **Address Obtained:** The **function’s entry point** address (the beginning of the function’s code). This is suitable if you need a callable pointer to the function itself. (In a dynamic-link scenario with interposition, it may point to a thunk/PLT that eventually calls the function.)

## 2. Using GCC Labels as Values (Pointer to an Internal Label)

GCC (and Clang) provide a non-standard extension that allows obtaining the address of an **internal label** within the function using the unary `&&` operator ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=You%20can%20get%20the%20address,For%20example)). For example:

```c
void myfunc(void) {
    void *here;
    goto LABEL;  // labels must be defined in function; use goto to ensure label existence
LABEL:
    here = &&LABEL;
    printf("Label address: %p\n", here);
    // ...
}
```

This sets `here` to the address of the label `LABEL` inside `myfunc`. This is a constant pointer of type `void*` representing a location in the function’s code ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=You%20can%20get%20the%20address,For%20example)).

- **Pros:** No assembly needed, and no function-pointer-to-data-pointer cast issues (the label address is already a `void*`). This yields an address *inside* the function’s code. It works on any architecture since it’s handled by the compiler. It can be useful for certain advanced techniques (like computed gotos or interpreter dispatch) and has zero runtime overhead (the address can be resolved at compile or link time).
- **Cons:** It’s non-standard (GCC/Clang specific). Not available in MSVC or strictly standard C. The address obtained is **not exactly the function entry** – it’s the location of the label, which could be in the middle or at the start of the function depending on placement. If you place the label at the top of the function, it will likely point to the instruction after the function’s prologue (after stack frame setup in a debug build). Thus, jumping to that label directly from outside the function would skip the prologue (not safe to call externally). This method is mainly useful for identifying a point in the function or doing internal jumps, rather than obtaining a re-callable function pointer. Another caution is that if the function is inlined or cloned by the compiler, the value of `&&LABEL` might differ per clone ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=The%20,inlining%20and%20cloning%20is%20forbidden)). In practice, you can prevent inlining with `__attribute__((noinline))` (which is default in -O0) to ensure the label address is consistent ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=The%20,inlining%20and%20cloning%20is%20forbidden)).
- **Portability:** Requires GCC or Clang. Not supported by MSVC. When used in position-independent code (PIE/PIC for dynamic linking), taking a label address may introduce a relocation. GCC documentation shows a technique of storing differences (`&&LABEL1 - &&LABEL2`) to avoid relocations for jump tables ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=An%20alternate%20way%20to%20write,the%20above%20example%20is)). In our scenario of simply getting the address at runtime, the compiler will handle it (possibly via a PC-relative load or relocation). It works in both static and dynamic binaries; in a dynamic binary the label’s address will be adjusted at load time just like any code address.
- **Address Obtained:** The address of the **label location inside the function**. This is typically an **internal code address** (neither the caller’s address nor necessarily the very start of the function, unless the label is at the start). It’s essentially a pointer into the function’s instruction stream.

## 3. Using Inline Assembly to Read the Program Counter

Another approach is to use inline assembly to directly capture the current instruction pointer (program counter) at runtime. This yields a code address at the point of execution inside the function. The implementation is architecture-specific:

### 3.a. Inline Assembly on x86

On x86 (both 32-bit and 64-bit), you cannot directly read the program counter via a register, but you can exploit the *call* instruction behavior to get the current address. A common trick is to perform a near call to the next instruction and then pop the return address off the stack. For example (AT&T syntax in GCC inline asm):

```c
void *addr;
__asm__ volatile (
    "call 1f;\n"    // call the label 1
    "1: pop %0;\n"  // pop the return address (label 1) into output register
    : "=r"(addr)
    :
    : /* no clobbers */
);
```

Here, `call 1f` pushes the address of label `1` (the instruction after the call) onto the stack, and `pop %0` pops that into the C variable `addr`. After this, `addr` holds the address *immediately after* the call instruction, which is an address inside the function at that point ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=Another%20way%20with%20a%20slightly,Looks%20like%20this)). This is effectively the runtime PC value.

On x86-64, a slightly more efficient variant uses the RIP-relative LEA instruction: `lea 0(%%rip), %rax` will load the address of the next instruction into RAX ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=You%20can%20get%20the%20value,instruction)). In GAS syntax, one can write `lea .(%rip), %rax` where `.` refers to the current location ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=You%20can%20get%20the%20value,instruction)). This accomplishes the same thing without using the stack. In 32-bit x86, there is no RIP register, so the call-pop method (or a direct `mov` of an immediate label address) is used.

- **Pros:** This yields a precise code address at runtime without relying on any library. It works in position-independent code because the call/lea uses relative addressing. It’s a general solution for x86: the call-pop trick works on 32-bit and 64-bit, and the LEA trick works on x86-64. Performance impact is minimal (modern CPUs treat a call immediately followed by a pop as a single efficient idiom and do not mispredict returns ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=Note%20that%20by%20design%2C%20this,ret))). This gives you an address *inside* the function (where the assembly is placed).
- **Cons:** Requires writing assembly, which is compiler- and architecture-specific. Inline assembly is supported in GCC/Clang, but MSVC **does not allow inline assembly in 64-bit mode**. (In 32-bit MSVC, you could use __asm blocks, but in 64-bit MSVC you’d need to write an external assembly function or use an intrinsic.) Also, the address you get is the location of the label/instruction *after* the call or LEA. If this snippet is at the very start of the function (after prologue), it will effectively give an address near the function’s beginning. But it might still be past the prologue instructions inserted by the compiler. So it’s an **internal address** in the function, not necessarily the official entry point. If you needed the absolute entry address, you would have to subtract the known offset of the prologue (not trivial or robust). Generally, this is used for getting a unique identifier for the function at runtime or for PC-relative computations. Another consideration is stack alignment on x86-64: the `call` pushes an 8-byte return address. In practice this is not an issue here since we pop it right away, but it does momentarily use stack space.
- **Portability:** Assembly syntax here is GCC-style. Clang also supports it. For MSVC, one would use an intrinsic or separate assembly (see section 4 for MSVC intrinsics). This method works in both static and dynamic binaries. Because it doesn’t rely on symbol addresses, it isn’t affected by PLT stubs or relocation differences – it grabs the actual runtime PC. Even if the function is in a shared library loaded at a random address, the relative call/LEA yields the correct address. (This method will not work if the function gets inlined away, but in debug builds with no-inline that’s avoided.)
- **Address Obtained:** The **current instruction address inside the function** at the point of the inline assembly. Essentially it’s a pointer into the function’s code near where the assembly is. This is neither the caller’s address nor necessarily the entry point, but a location within the function itself (useful for identifying the function context uniquely).

### 3.b. Inline Assembly on ARM (ARM32 and ARM64)

On ARM architecture, the program counter (PC) can often be accessed or computed via special instructions:

- **ARM64 (AArch64):** The architecture provides the `ADR` instruction to obtain a PC-relative address. Using inline asm, one can do: 
  ```c
  void *addr;
  __asm__("adr %0, .\n" : "=r"(addr));
  ``` 
  This places the address of the `adr` instruction (i.e., the current PC) into `addr` ([MISC study notes about ARM AArch64 Assembly and the ARM Trusted Execution Environment (TEE)](https://0x434b.dev/misc-study-notes-about-arm-aarch64-assembly-and-the-arm-trusted-execution-environment-tee/#:~:text=,of%204KB%20page%20containing%20label)). Another option is to use a label: `adr %0, label\n label:` would give the address of `label`. Either way, it’s similar to the x86 LEA approach, yielding a runtime code address. ARM64’s PC in the assembler is the address of the current instruction (unlike ARM32, see below), so `adr x0, .` gives the address of that `adr` itself ([MISC study notes about ARM AArch64 Assembly and the ARM Trusted Execution Environment (TEE)](https://0x434b.dev/misc-study-notes-about-arm-aarch64-assembly-and-the-arm-trusted-execution-environment-tee/#:~:text=,of%204KB%20page%20containing%20label)). (You could also use `adrp` for page addresses, but that’s not needed just to get the function address). 

- **ARM 32-bit (ARMv7/AArch32):** In ARM (A32) state, you can use the `ADR` pseudo-instruction as well. For example:
  ```c
  void *addr;
  __asm__("adr %0, here\n here:\n" : "=r"(addr));
  ``` 
  This will load the address of the label `here` into `addr` (PC-relative calculation). In Thumb mode, `ADR` works with a ±4KB range, which is fine within a single function. Alternatively, one could read the PC directly: on ARM, many instructions treat the PC as a readable register. For instance, `mov r0, pc` will put the current PC value in r0 – *but note:* on classic ARM, the reported PC is often **ahead of the current instruction** due to pipelining. In ARM state, `pc` reads as the address of the current instruction plus 8 bytes; in Thumb state it’s usually current address + 4 bytes (with alignment) ([assembly - Why does the ARM PC register point to the instruction after the next one to be executed? - Stack Overflow](https://stackoverflow.com/questions/24091566/why-does-the-arm-pc-register-point-to-the-instruction-after-the-next-one-to-be-e#:~:text=According%20to%20the%20ARM%20IC)). So a `mov r0, pc` executed at a given point will actually give an address a couple of instructions ahead. Using an explicit label with `ADR` avoids having to account for this offset, because the assembler will compute the correct relative offset to the label. If using `mov pc` directly, you might need to subtract 8 or 4 to get the exact current location. Using `ADR` or a branch-and-link is easier:
    - Another method: `bl 1f; 1: mov %0, lr` – branch to label 1, which sets the link register (LR) to the address after the branch (label 1), then move LR to the output. This is analogous to call-pop but using LR instead of the stack (because ARM’s `BL` saves return address in LR). This yields the address at label 1 as well. Just be careful if you use `BL` that you don’t clobber LR if it was needed (in a non-leaf function, LR is usually pushed on stack in the prologue in ARM, so one could safely use a BL within if one later returns normally via the stack’s LR).

- **Pros:** Like the x86 case, this gives a direct code address within the function at runtime. No external calls or data needed. On ARM64, the `ADR` approach is very efficient (a single instruction). On ARM32, `ADR` or a small `BL`/`mov` sequence is also efficient. These methods naturally support position-independent code since they are PC-relative. They work regardless of whether the binary is static or PIE.
- **Cons:** Requires inline assembly and is tied to GCC/Clang syntax (or assembly files for other compilers). MSVC for ARM (on Windows ARM) may not support inline assembly at all in user code. Another consideration on AArch64 systems with pointer authentication (PAC): if return addresses are signed, reading the PC via `ADR` will give you an unsigned actual code address (which is fine for identifying the location). But if one were reading the *LR register* directly on a system with PAC, the value might be “mangled” with a signature ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=The%20stored%20representation%20of%20the,is%20not)). However, using `adr %0, .` avoids that since it doesn’t involve LR or a stored return address. In general, this method is safe and straightforward in debug builds. Like before, the address is internal to the function (not the entry).
- **Portability:** Supported on GCC/Clang. Not in MSVC (which doesn’t support inline asm on ARM64, and on ARM32 it’s generally not available in Microsoft compilers either). If needed, you could write a small assembly function that returns the PC. The approach works uniformly in static or dynamic linking – it always yields the actual runtime address where it’s used.
- **Address Obtained:** The **current function’s code address at the point of execution** (or at a label). It’s an address *inside* the function. Not the caller’s address and not necessarily the very start of the function, but part of the function’s code space.

## 4. Using Compiler Built-ins/Intrinsics (Return Address of Caller)

Although not giving the function’s own entry address, another class of techniques is to query the *return address* (the caller’s address) from within the function. This can serve to identify “where am I called from,” which is slightly different but related. Since the question asks for all techniques, we include these for completeness. In GCC/Clang, the built-in `__builtin_return_address(level)` can retrieve return addresses; and in MSVC, the `_ReturnAddress()` intrinsic serves a similar purpose.

- **GCC/Clang `__builtin_return_address`:** This GNU C extension returns the return address of the current function when called with 0. For example:
  ```c
  void *ra = __builtin_return_address(0);
  ``` 
  will put the return address of the current function (i.e., the address in the caller where this function will return to) into `ra`. By definition, level 0 yields the immediate caller’s address ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=value%20of%20,function%20attribute)), level 1 would yield the caller of the caller, etc. In practice, level > 0 can be unreliable and is **only meant for debugging** – even level 0 is not 100% portable but works in typical scenarios (requires a frame pointer or equivalent). You often combine it with `__builtin_extract_return_addr()` to get a canonical code address ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=Additional%20post,builtin_extract_return_addr)) ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=On%20targets%20where%20code%20addresses,void)). For instance:
  ```c
  void *ra = __builtin_extract_return_addr(__builtin_return_address(0));
  ```
  This fixes up any encoding (for example, on systems where the return address might have a tag or offset in memory) ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=The%20stored%20representation%20of%20the,is%20not)) ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=On%20targets%20where%20code%20addresses,void)). In a normal platform like x86 or standard ARM, extract may just pass it through.

- **MSVC `_ReturnAddress()`:** Microsoft Visual C++ offers an intrinsic in `<intrin.h>` that provides the return address. Example:
  ```c
  #include <intrin.h>
  #pragma intrinsic(_ReturnAddress)
  void *ra = _ReturnAddress();
  ```
  This does the same thing – it gives the address of the next instruction in the calling function (the point to return to) ([cpp-docs/docs/intrinsics/returnaddress.md at main · MicrosoftDocs/cpp-docs · GitHub](https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/intrinsics/returnaddress.md#:~:text=The%20,control%20returns%20to%20the%20caller)). It’s available in both 32-bit and 64-bit MSVC. (MSVC also has `_AddressOfReturnAddress()` to get the stack location of that address, but that’s not needed here.)

- **Pros:** These built-ins are easy to use (no assembly needed in your C code) and are *intended for debugging purposes*. They allow a function to determine who called it (by address), which can indirectly identify the function itself in some contexts (for example, if you have a symbol table or backtrace mechanism, you could map that address to a function name). They do not give the function’s own entry directly, but the question hints at “call site or return address,” so this is a technique yielding that information. In a **debug build** (no optimization, frame pointers intact), `__builtin_return_address(0)` and `_ReturnAddress()` are generally reliable for the immediate caller. They require no external library.
- **Cons:** The value obtained is the **caller’s address**, not the callee’s. So this technique answers a slightly different question (“where am I called from?” rather than “what is my address?”). If the goal is truly to get the function’s *own* address, this doesn’t directly provide it – you would have to then use other means to map the return address back to the function (which typically requires symbol info or unwinding, which we are avoiding). These built-ins also come with caveats: **compiler optimizations can break assumptions**. If the function is inlined, there is no distinct return address for it – GCC documents that if inlined, it may return the address of the function that is returned to ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=value%20of%20,function%20attribute)). Tail call optimizations could eliminate frames such that `__builtin_return_address(0)` might skip some levels. Many compilers will issue a warning or restrict usage of these intrinsics by default (GCC with `-Wframe-address` warns that non-zero levels are unsafe ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=Calling%20this%20function%20with%20a,be%20made%20in%20debugging%20situations))). In general, you should use these only in debugging or instrumentation scenarios, not in production logic.
- **Portability:** `__builtin_return_address` is supported by GCC and Clang on many architectures (x86, ARM, etc.), but it’s non-standard C. MSVC’s `_ReturnAddress` is specific to MSVC on x86/x64 (and presumably on ARM Windows as well). Other compilers (ICC, etc.) may have their own intrinsics. Using these in cross-platform code might require `#ifdef` blocks. Also, they rely on the platform’s stack frame convention. On architectures where the return address isn’t easily accessible or doesn’t exist (some DSPs or very strict security modes), it may be unavailable. But on x86 and ARM it’s fine (on ARM, GCC’s builtin knows to use the link register or stack as appropriate).
- **Address Obtained:** The **call site address (return address)** in the *caller* function. In other words, it points to the instruction *after* the call in whatever function called our function ([cpp-docs/docs/intrinsics/returnaddress.md at main · MicrosoftDocs/cpp-docs · GitHub](https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/intrinsics/returnaddress.md#:~:text=The%20,control%20returns%20to%20the%20caller)). This is neither the current function’s start nor a point inside it, but an address outside, which can identify the caller. If you specifically need the current function’s address, this method alone isn’t sufficient, but it can complement other techniques (for example, one could combine this with unwinding or symbolize it to get the function name).

## Comparison Summary

To choose a method, consider what you need:

- **Function’s own entry address:** Use the function pointer technique (straight C) for simplicity. This gives the true entry point and is portable, but be mindful of potential PLT indirection in shared libraries. Alternatively, a label+assembly at the very start could approximate the entry (with some caveats). 
- **An address inside the function (for identification):** Inline assembly (x86 `call/pop` or ARM `ADR`) or GCC label addresses both provide a pointer into the function’s code. These are useful for tagging the function uniquely at runtime without relying on symbol names. Assembly works in more compilers than the GCC label extension, but requires per-arch code.
- **Caller’s address (return address):** Compiler built-ins/intrinsics provide the return address on stack or LR register. Useful for backtracing who called the function (e.g., simple profiling or debug messages showing caller location).

In debug builds (no optimization), all these methods are generally safe: functions won’t be inlined or omitted, frame pointers exist (making return-address builtins work reliably), and code order is predictable. In optimized builds, extra care is needed (mark functions `noinline` if using these techniques, etc., as noted above).

Below is a quick pros/cons table for clarity:

- **Function Pointer (`&func`):** *Pros:* Easiest, portable C code, entry-point address. *Cons:* Function pointer to `void*` cast UB (practically OK), in PIC might yield PLT address if not static, requires function not inlined. *Yields:* Function entry address ([pointers - Get address of a function inside of the function in C/C++? - Stack Overflow](https://stackoverflow.com/questions/63395637/get-address-of-a-function-inside-of-the-function-in-c-c#:~:text=In%20C%20you%20can%20use,has%20the%20wrong%20return%20type)).
- **GCC Label (`&&label`):** *Pros:* No runtime cost, get internal address. *Cons:* GCC/Clang only, not actual entry if label not at start, not callable as function entry, prevent inlining ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=The%20,inlining%20and%20cloning%20is%20forbidden)). *Yields:* Address of label (in-function code) ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=You%20can%20get%20the%20address,For%20example)).
- **Inline ASM (x86 call/pop or LEA):** *Pros:* Works on x86 32/64, position-independent, minimal overhead ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=Another%20way%20with%20a%20slightly,Looks%20like%20this)) ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=You%20can%20get%20the%20value,instruction)). *Cons:* Not in standard C, MSVC x64 doesn’t support inline asm, yields internal address (after prologue). *Yields:* Current instruction address inside function.
- **Inline ASM (ARM ADR/BL):** *Pros:* Works on ARM32/64, PC-relative, efficient (especially ADR) ([MISC study notes about ARM AArch64 Assembly and the ARM Trusted Execution Environment (TEE)](https://0x434b.dev/misc-study-notes-about-arm-aarch64-assembly-and-the-arm-trusted-execution-environment-tee/#:~:text=,of%204KB%20page%20containing%20label)). *Cons:* Requires GCC/Clang, not available in MSVC, care with ARM PC pipeline (+4/8) if using direct PC read ([assembly - Why does the ARM PC register point to the instruction after the next one to be executed? - Stack Overflow](https://stackoverflow.com/questions/24091566/why-does-the-arm-pc-register-point-to-the-instruction-after-the-next-one-to-be-e#:~:text=According%20to%20the%20ARM%20IC)). *Yields:* Current instruction address inside function.
- **Built-in `__builtin_return_address` / `_ReturnAddress`:** *Pros:* Easy to use, gives caller’s location ([cpp-docs/docs/intrinsics/returnaddress.md at main · MicrosoftDocs/cpp-docs · GitHub](https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/intrinsics/returnaddress.md#:~:text=The%20,control%20returns%20to%20the%20caller)). *Cons:* Non-standard, only gives **caller** address (not self), needs frame pointers (debug mode), unsafe if overused in optimized code ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=Calling%20this%20function%20with%20a,be%20made%20in%20debugging%20situations)). *Yields:* Return address (call site in caller) ([cpp-docs/docs/intrinsics/returnaddress.md at main · MicrosoftDocs/cpp-docs · GitHub](https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/intrinsics/returnaddress.md#:~:text=The%20,control%20returns%20to%20the%20caller)).

Each technique has its niche. In summary, **for getting the function’s own address**, the most straightforward in C is using the function’s name (function pointer). If you need the address *during execution* (for example, to compute relative offsets or just as an ID), the inline assembly approach is very effective on both x86 and ARM. The GCC label method is elegant if you are already using GCC-specific features. And if you actually wanted to know the *caller* (not the function itself), then the built-in return address intrinsics are the way to go. All these require no external libraries and work in both static and dynamic binaries (with notes as above).

**Sources:**

- The BusyBee’s comment on using a function’s address in C ([pointers - Get address of a function inside of the function in C/C++? - Stack Overflow](https://stackoverflow.com/questions/63395637/get-address-of-a-function-inside-of-the-function-in-c-c#:~:text=In%20C%20you%20can%20use,has%20the%20wrong%20return%20type)).  
- GCC documentation on labels as values (address of a label via `&&`) ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=You%20can%20get%20the%20address,For%20example)) (and implications for inlining ([Labels as Values (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#:~:text=The%20,inlining%20and%20cloning%20is%20forbidden))).  
- Stack Overflow answer illustrating x86_64 techniques to get the current RIP using `LEA` and `CALL...POP` ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=You%20can%20get%20the%20value,instruction)) ([assembly - Can I do the equivalent of jmping to a label by saving and modifying the Instruction Pointer? - Stack Overflow](https://stackoverflow.com/questions/53601766/can-i-do-the-equivalent-of-jmping-to-a-label-by-saving-and-modifying-the-instruc#:~:text=Another%20way%20with%20a%20slightly,Looks%20like%20this)).  
- ARM assembly references for obtaining PC: AArch64 `ADR Xn, .` yields the current PC ([MISC study notes about ARM AArch64 Assembly and the ARM Trusted Execution Environment (TEE)](https://0x434b.dev/misc-study-notes-about-arm-aarch64-assembly-and-the-arm-trusted-execution-environment-tee/#:~:text=,of%204KB%20page%20containing%20label)); on ARM, PC reads as current instr + 8 (ARM) or +4 (Thumb) bytes ([assembly - Why does the ARM PC register point to the instruction after the next one to be executed? - Stack Overflow](https://stackoverflow.com/questions/24091566/why-does-the-arm-pc-register-point-to-the-instruction-after-the-next-one-to-be-e#:~:text=According%20to%20the%20ARM%20IC)).  
- GCC documentation for `__builtin_return_address`, describing level=0 returning the caller’s return address ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=value%20of%20,function%20attribute)) and its intended use in debugging ([Return Address (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html#:~:text=Calling%20this%20function%20with%20a,be%20made%20in%20debugging%20situations)).  
- Microsoft documentation for the `_ReturnAddress` intrinsic (caller’s next-instruction address) ([cpp-docs/docs/intrinsics/returnaddress.md at main · MicrosoftDocs/cpp-docs · GitHub](https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/intrinsics/returnaddress.md#:~:text=The%20,control%20returns%20to%20the%20caller)).
